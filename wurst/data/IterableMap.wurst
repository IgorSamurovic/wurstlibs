package IterableMap 
import public LinkedList
import public HashMap

import public TypeCasting
import public Table

/** Iterable Table Wrapper */
public class IterableMap<K,V> extends HashMap<K, V>
 	private let keys = new LinkedList<K>()

 	function iterator() returns LLIterator<K>
 	 	return keys.iterator()

 	function staticItr() returns LLStaticIterator<K>
 	 	return keys.staticItr()

	/** Returns whether the key is used */
	override function has(K key) returns bool
		return keys.contains(key)

	/** Returns a shallow copy of this map */
	function clone() returns IterableMap<K, V>
		let map = new IterableMap<K, V>
		for key in this
			map.put(key, get(key))
		return map

 	/** Saves the given value under the given key */
	override function put(K key, V value)
 	 	super.put(key, value)
		if not keys.contains(key)
 	 	 	keys.add(key)
	
	/** Removes the value saved under the given key */
	override function remove(K key)
		super.remove(key)
 	 	if keys.contains(key)
 	 	 	keys.remove(key)

	/** Returns the list of keys */
	function getKeys() returns LinkedList<K>
		return keys

 	ondestroy
 	 	destroy keys