package Object2D
import VectorExtension
import MathExtension

constant DEBUG = false //= true

public abstract class Object2D
    protected vec2 center
    protected vec2 min
    protected vec2 max
    protected bool updated = false

    function getCenter() returns vec2
        return center

    function setCenter(vec2 vec)
        center = vec
        updated = false
    
    abstract function checkCollision(Object2D obj) returns bool
    
    function update()

    function checkBounding(Object2D obj) returns bool
        return max.x >= obj.min.x and max.y >= obj.min.y
            or min.x <= obj.max.x and min.y <= obj.max.y

public class Circle extends Object2D
    protected real radius

    override function update()
        if not updated
            min = center - vec2(radius, radius)
            max = center + vec2(radius, radius)
            updated = true

    override function checkCollision(Object2D obj) returns bool
        update()
        if checkBounding(obj)
            if obj.typeId == Rectangle.typeId
                return obj castTo Rectangle.checkCollision(this)
            else
                let radius = this.radius + (obj castTo Circle).radius
                return center.distanceToSq((obj castTo Circle).center) < radius * radius
        else
            return false
        
    construct(vec2 center, real radius)
        this.radius = radius
        setCenter(center)

public class Rectangle extends Object2D
    protected lightning array[4] DEBUGLIGHT
    protected real array[4] x
    protected real array[4] y

    protected real cos
    protected real sin

    protected angle facing

    protected vec2 dimension
    protected vec2 offset
    protected vec2 angOffset

    function setAngle(angle ang)
        facing = ang
        updated = false

    function moveBy(vec2 vec)
        center += vec
        updated = false

    function getDimensions() returns vec2
        return dimension

    override function update()
        if not updated
            angOffset = offset.rotate(facing)
            sin = facing.sin()
            cos = facing.cos()
            updatePoints()
            updateExtremes()
            updated = true

    static function rotate(real x, real y, real c, real s) returns vec2
        let px = x * c - y * s
        let py = x * s + y * c
        return vec2(px, py)

    function updatePoints()
        var c = facing.cos()
		var s = facing.sin()

        var p = rotate(offset.x, offset.y, c, s)
        x[0] = center.x + p.x
        y[0] = center.y + p.y
        p = rotate(offset.x, -offset.y, c, s)
        x[1] = center.x + p.x
        y[1] = center.y + p.y
        p = rotate(-offset.x, -offset.y, c, s)
        x[2] = center.x + p.x
        y[2] = center.y + p.y
        p = rotate(-offset.x, offset.y, c, s)
        x[3] = center.x + p.x
        y[3] = center.y + p.y
        
        if not compiletime and DEBUG
            MoveLightning(DEBUGLIGHT[0], false, x[0], y[0], x[1], y[1])
            MoveLightning(DEBUGLIGHT[1], false, x[1], y[1], x[2], y[2])
            MoveLightning(DEBUGLIGHT[2], false, x[2], y[2], x[3], y[3])
            MoveLightning(DEBUGLIGHT[3], false, x[3], y[3], x[0], y[0])

    function updateExtremes()
        min = vec2(1000000, 1000000)
        max = vec2(-1000000, -1000000)
        for i=0 to 3
            if x[i] > max.x
                max.x = x[i]
            if x[i] < min.x
                min.x = x[i]
            if y[i] > max.y
                max.y = y[i]
            if y[i] < min.y
                min.y = y[i]

    construct(vec2 center, vec2 dim, angle facing)
        this.center = center
        this.dimension = dim
        this.facing = facing
        this.offset = 0.5 * dim
        if not compiletime and DEBUG
            DEBUGLIGHT[0] = AddLightningEx("CLPB", false, 0, 0, 0, 0, 0, 0)
            DEBUGLIGHT[1] = AddLightningEx("CLPB", false, 0, 0, 0, 0, 0, 0)
            DEBUGLIGHT[2] = AddLightningEx("CLPB", false, 0, 0, 0, 0, 0, 0)
            DEBUGLIGHT[3] = AddLightningEx("CLPB", false, 0, 0, 0, 0, 0, 0)
        update()

    override function checkCollision(Object2D obj) returns bool
        update()
        if checkBounding(obj)
            if obj.typeId == Rectangle.typeId
                let that = obj castTo Rectangle
                return ((max.x <= that.max.x and max.x >= that.min.x) or (min.x <= that.max.x and min.x >= that.min.x))
                and    ((max.y <= that.max.y and max.y >= that.min.y) or (min.y <= that.max.y and min.y >= that.min.y))     
            else
                let that = obj castTo Circle
                return center.distanceTo(that.center) <= that.radius or getAnglePoint(center.angleTo(that.center)).distanceTo(that.center) <= that.radius
        else
            return false

    function getNormalForPos(angle pos)


    function getAnglePoint(angle ang) returns vec2
        var x = 0.
        var y = 0.

        let deg = ang.normalize().degrees()

        // Calculate X first
        if deg >= 315 or deg < 45
            x = 1
        else if deg < 90
            x = 1 -(deg - 45) / 45
        else if deg < 135
            x = -(deg - 90) / 45
        else if deg < 225
            x = -1
        else if deg < 270
            x = -1 +(deg - 225) / 45
        else if deg < 315
            x = (deg - 270) / 45

        // Calculate Y
        if deg >= 0 and deg < 45
            y = deg / 45
        else if deg < 135
            y = 1
        else if deg < 180
            y = 1 -(deg - 135) / 45
        else if deg < 225
            y = -(deg - 180) / 45
        else if deg < 315
            y = -1
        else if deg <= 360
            y = -1 + (deg - 315) / 45

        return center + vec2(angOffset.x * x, angOffset.y * y)

@Test function test()
    let rect1 = new Rectangle(vec2(0, 0), vec2(2, 2), angle(0))
    let rect2 = new Rectangle(vec2(2, 2), vec2(3, 3), angle(0))
    let circ = new Circle(vec2(0, 2), 1)
    print("|n")
    
    for i=0 to 3
        print(rect1.x[i].toString() + ", " + rect1.y[i].toString())
    for i=0 to 3
        print(rect2.x[i].toString() + ", " + rect2.y[i].toString())

    print(rect1.checkCollision(rect2))