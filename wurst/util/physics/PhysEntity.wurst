package PhysEntity
import TimerUtils
import LinkedListModule
import HashMap

public class PhysEntity
    use LinkedListModule

    static let TIMER = getTimer()
    static let TIMEOUT = 0.01

    static let instanceMap = new HashMap<unit, thistype>()

    protected unit u
    protected real weight = 1
    protected real collision = 16
    protected vec3 pos
    protected vec3 oldPos

    protected vec3 inertia = vec3(0, 0, 0)

    protected angle pitch = angle(0)
    protected angle roll = angle(0)
    protected angle facing = angle(0)

    function isAirborne() returns bool
        return pos.z - getTerrainZ(pos.x, pos.y) > 1.1 * collision

    private static real array zvals

    function updateValues()
        let pos2D = vec2(pos.x, pos.y)

        facing = u.getFacingAngle()

        for i=0 to 3
            zvals[i] = getTerrainZ(pos2D.polarOffset(facing + angle(PIHALF * i), 8))
        
        pitch = angle(Asin(zvals[0] - zvals[2])/16)
        roll = angle(Asin(zvals[1] - zvals[3])/16)

    static vec2 array circle = [vec2(1, 0), vec2(0, 1), vec2(-1, 0), vec2(0, -1)]

    function applyGravity()
        vec3 gravity = vec3(0, 0, 0)
        let centerZ = getTerrainZ(pos.x, pos.y)
        
        let offground = pos.z - centerZ

        // If still flying
        if offground > collision
            inertia.z -= 20 * TIMEOUT
        // If been grounded for a while
        else
            // Calculate terrain heights
            for i = 0 to 3
                let z = getTerrainZ(vec2(pos.x, pos.y) + circle[i] * 8)
                let diff = z - centerZ
                if diff > 0
                    gravity -= circle[i] * (diff) * TIMEOUT
                    if inertia.z <= 0
                        inertia.z += gravity.length()

            if inertia.z < 0
                inertia.z = 0

            let zGain = (pos + inertia).z - oldPos.z
            let ang = oldPos.toVec2().angleTo(pos.toVec2())
            let travelled = oldPos.distanceTo(pos + inertia)
            inertia.z += (travelled/2.5) * zGain * TIMEOUT

            inertia += gravity
    
    function applyFriction()
        let multiplier = getTerrainFriction(vec2(pos.x, pos.y))
        if not isAirborne()
            inertia *= multiplier

    function applyInertia()
        pos += inertia

    function addInertia(vec3 inertia)
        this.inertia += inertia

    function collide(PhysEntity another)
        var give = this.weight / (another.weight + this.weight)
        var take = 1 - give
        //print(give)
        let ang = pos.angleTo2d(another.pos)

        var currentInertia = vec3(inertia.x * ang.cos(), inertia.y * ang.sin(), 0)
        var currentAnotherInertia = vec3(another.inertia.x * ang.cos(), another.inertia.y * ang.sin(), 0)

        another.addInertia(give * currentInertia)
        another.addInertia((-give) * currentAnotherInertia)
        this.addInertia(take * currentAnotherInertia)
        this.addInertia((-take) * currentInertia)

        let posDiff = 0.01 * (pos - another.pos)
        another.pos -= give * posDiff
        pos += take * posDiff

    function applyCollision()
        ENUM_GROUP.enumUnitsInRange(vec2(pos.x, pos.y), 256)
        for v in ENUM_GROUP
            if v != this.u
                let pe = v.getPhysEntity()
                if pe != null
                    let dist = pos.distanceTo(pe.pos)
                    
                    let collisionSum = pe.collision + collision 
                    // Test if they collide
                    if collisionSum > dist
                        this.collide(pe)

    static vec2 array circle8 = [vec2(1, 0), vec2(0.7, 0.7), vec2(0, 1), vec2(-0.7, 0.7),
        vec2(-1, 0), vec2(-0.7, -0.7), vec2(0, -1), vec2(0.7, -0.7)]

    static vec2 array pushback = [vec2(1, 0), vec2(1, 1), vec2(0, 1), vec2(1, 1),
        vec2(1, 0), vec2(1, 1), vec2(0, 1), vec2(1, 1)]

    function applyTerrainCollision()
        var push = vec2(0, 0)
        var hits = 0
        for i = 0 to 7
            let z = getTerrainZ(vec2(pos.x, pos.y) + circle8[i] * (collision + 8))
            let diff = z - pos.z
            if diff > 120
                hits++
                push += pushback[i]

        if hits > 0
            push = 1/hits * push
            inertia.x *= -push.x
            inertia.y *= -push.y

    function process()
        updateValues()

        applyGravity()
        applyFriction()
        applyInertia()
        applyCollision()
        applyTerrainCollision()
        
        u.setX(pos.x)
        u.setY(pos.y)

        let terrainZ = getTerrainZ(pos.x, pos.y)
        pos.z = RMaxBJ(pos.z, terrainZ)
        u.setFlyHeight(pos.z-terrainZ, 0)

        //if not isAirborne()
        //    pos.z = u.getPos3Real().z

        SetUnitTimeScale(u, 0.3 * (inertia.x.abs() + inertia.y.abs()))
        oldPos = pos

    construct(unit u, real collision, real weight)
        this.u = u
        this.pos = u.getPos3Real()
        this.pos.z += collision
        this.oldPos = pos
        this.collision = collision 
        this.weight = weight
        instanceMap.put(u, this)

    static function processAll()
        for entity in PhysEntity
            entity.process()

    static function start()
        TIMER.startPeriodic(TIMEOUT, () -> processAll())

    static function stop()
        TIMER.pause()

    static function of(unit u) returns thistype
        return instanceMap.get(u)

    ondestroy
        instanceMap.remove(u)

init
    PhysEntity.start()
    
public function unit.getPhysEntity() returns PhysEntity
    return PhysEntity.of(this)

// HELPER FUNCTION BLOCK

location TheLoc = Location(0,0)

function getTerrainZ(real x, real y) returns real
    MoveLocation(TheLoc,x,y)
    return GetLocationZ(TheLoc)

function getTerrainZ(vec2 pos) returns real
    MoveLocation(TheLoc, pos.x, pos.y)
    return GetLocationZ(TheLoc)

function getTerrainFriction(vec2 pos) returns real
    return 0.99

function unit.setFlyHeight(real height)
    this.setFlyHeight(RMaxBJ(0, height), 1000000000)

function unit.addFlyHeight(real toAdd)
    this.setFlyHeight(this.getFlyHeight() + toAdd)

function unit.addPos(vec3 pos)
    this.setPos(pos.x, pos.y)
    this.setFlyHeight(this.getFlyHeight() + pos.z)
