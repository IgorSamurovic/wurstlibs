package Tooltip
import List
import Hotkey
import StringUtils
import AbilityObjEditing
import IterableMap
import LinkedList
import ColorSet
import JTML
import StringExtension

/* PROCESSING CHAIN */
/*
    1) Input a value into the tooltip
    2) The value is processed with the appropriate style (or none if none found)
    3) The value is added to the fields list, with an appended level if needed
    4) Once the tooltip is requested, the template is filled with field values for the appropriate level
*/

function RealLevelClosure.toStringList(int levels) returns List<string>
    let list = new List<string>
    for lvl=1 to levels
        list.add(this.run(lvl).toString())
    return list

function IntLevelClosure.toStringList(int levels) returns List<string>
    let list = new List<string>
    for lvl=1 to levels
        list.add(this.run(lvl).toString())
    return list

function StringLevelClosure.toStringList(int levels) returns List<string>
    let list = new List<string>
    for lvl=1 to levels
        list.add(this.run(lvl))
    return list

public class TooltipTemplate
    static let BASIC   = "{hotkey} {action} {name} {level}"

    static let NONE            = "{value}"
    static let NORMAL          = "{name} {value}"
    static let INDENT          = "{name}    {value}"
    static let NEWLINE         = "{name}|n{value}"
    static let NEWLINE_INDENT  = "{name}|n    {value}"
    static let SEPARATOR       = "{name}{separator}{value}"

public class TooltipStyle
    static IterableMap<string, string> BASIC = new IterableMap<string, string>()
        ..put("hotkey", "[<c em>{hotkey}</c>]")
        ..put("level" , "[<c em>Level {level}</c>]")
    static IterableMap<string, string> EXTENDED = new IterableMap<string, string>()
        ..put("name"  , "<c em>{name}</c>:")
        ..put("value" , "{value}")
        ..put("active"    , "<c em>{active}</c>")
        ..put("inactive"  , "<c #CCCCCC>{inactive}</c>")
public class StringSeparator
    static let NONE = ""
    static let NORMAL = ", "
    static let COMMA = ","
    static let SPACE = " "
    static let NEWLINE = "|n"
    static let NEWLINE_INDENT = "|n    "
    static let INDENT = "    "

public class Tooltip
    static let DEFAULT_BASIC_TEMPLATE    = TooltipTemplate.BASIC
    static let DEFAULT_FRAGMENT_TEMPLATE = TooltipTemplate.NORMAL
    static let DEFAULT_BASIC_STYLE       = TooltipStyle.BASIC
    static let DEFAULT_EXTENDED_STYLE    = TooltipStyle.EXTENDED
    static let DEFAULT_SEPARATOR         = StringSeparator.NORMAL

    protected var basicTemplate     = DEFAULT_BASIC_TEMPLATE
    protected var basicStyle        = DEFAULT_BASIC_STYLE

    protected var fragmentTemplate  = DEFAULT_FRAGMENT_TEMPLATE
    protected var fragmentStyle     = DEFAULT_EXTENDED_STYLE
    protected var fragmentSeparator = DEFAULT_SEPARATOR

    protected let basicFragment = new TooltipFragment(this)
    protected let fragments     = new List<TooltipFragment>()


    protected int levels = 5
    protected int nextPriority = -1

    function setNextPriority(int priority)
        this.nextPriority = priority

    function getNextPriority() returns int
        if this.nextPriority != -1
            let retVal = nextPriority
            nextPriority = -1
            return retVal
        else if fragments.getSize() > 0
            return fragments.peek().getPriority()
        else
            return 0

    function getBasicFragment() returns TooltipFragment
        return basicFragment

    /** Sets the basic template that will be used to create basic tooltip. */
    function setBasicTemplate(string template)
        basicTemplate = template

    /** Sets the default style for parts of the basic tooltip. */
    function setBasicStyle(IterableMap<string, string> style)
        basicStyle = style

    /** Sets the fragment template to be used in case fragment does not have its own setting. */
    function setFragmentTemplate(string template)
        fragmentTemplate = template

    /** Sets the default style for parts of the extended tooltip. */
    function setFragmentStyle(IterableMap<string, string> style)
        fragmentStyle = style

    /** Sets the default separator for parts of the extended tooltip. */
    function setFragmentSeparator(string separator)
        fragmentSeparator = separator

    /** Returns the basic tooltip. */
    function getBasicTip() returns string
        return basicFragment.getTooltip().trim().reduce()

    /** Returns the basic tooltip for a specificed level. */
    function getBasicTip(int level) returns string
        if level > 0
            return basicFragment.getTooltip(level).trim().reduce()
        else
            return getBasicTip()
            
    /** Returns the extended tooltip. */
    function getExtendedTip() returns string
        string tip = ""
        this.sortFragments()
        for fragment in fragments
            tip += fragment.getTooltip() + "|n"
        return tip

    /** Returns the extended tooltip. */
    function getExtendedTip(int level) returns string
        string tip = ""
        this.sortFragments()
        for fragment in fragments
            if fragment.getTemplate() == null   
                fragment.setTemplate(fragmentTemplate)
            if fragment.getStyle() == null
                fragment.setStyle(fragmentStyle)
            
            tip += fragment.getTooltip(level) + "|n"
        return tip
 
    construct()
        basicFragment
            ..setStyle(basicStyle)
            ..setTemplate(basicTemplate)
            ..setSeparator("")

    /** Constructs a tooltip object based on fields. */
    construct(string action, string name, Hotkey hotkey, int levels)
        this.levels = levels
        basicFragment
            ..setStyle(basicStyle)
            ..setTemplate(basicTemplate)
            ..setSeparator("")
        if action != ""
            basicFragment.setField("action", action)
        if name != ""
            basicFragment.setField("name", name)
        if hotkey != null
            basicFragment.setField("hotkey", hotkey.getChar())

    /** Sort the fragments by priority */
    function sortFragments()
        fragments.sortBy((TooltipFragment obj1, TooltipFragment obj2) -> obj1.getPriority() < obj2.getPriority() )

    function removeFragment(TooltipFragment fragment)
        fragments.remove(fragment)

    function addFragment() returns TooltipFragment
        let fragment = new TooltipFragment(this)
            ..setTemplate(fragmentTemplate)
            ..setStyle(fragmentStyle)
            ..setSeparator(fragmentSeparator)
            ..setPriority(getNextPriority() + 1)

        fragments.add(fragment)

        return fragment

    function addFragment(bool conditionsMet) returns TooltipFragment
        if compiletime and conditionsMet
            return addFragment()
        else
            return new TooltipFragment(null)


public class TooltipFragment
    protected Tooltip parent

    protected var priority = 0
    protected let fields = new IterableMap<string, string>() //typically "hotkey", "action", "name", "level"

    protected string template
    protected IterableMap<string, string> style
    protected string separator

    protected bool addNewline = false

    function addNewline()
        addNewline = true

    /** Sets the basic template that will be used to create basic tooltip. */
    function setTemplate(string template)
        this.template = template

    function getTemplate() returns string
        return template

    /** Sets the default style for parts of the basic tooltip. */
    function setStyle(IterableMap<string, string> style)
        this.style = style
    
    function getStyle() returns IterableMap<string, string>
        return style

    /** Sets the default separator for parts of the basic tooltip. */
    function setSeparator(string sep)
        this.separator = sep
        this.fields.put("separator", sep)
    
    function getSeparator() returns string
        return separator

    /* Field manipulation */

    function format(string key, string value) returns string
        return style.get(key).r(key, value)

    function setField(string key, string value)
        fields.put(key, format(key, value))

    /** Adds a level-independant list field to the map, formatting the string passed. */
    function setListField(string key, List<string> values, string separator)
        for i=0 to values.getSize() - 1
            values.set(i, format(key, values.get(i)))
        fields.put(key, values.joinBy(separator))
        destroy values

    /** Adds a level-dependant string-based field. */
    function setLvlFields(string key, List<string> values, string separator)
        for lvl=1 to parent.levels
            let list = values.clone()
            for sublvl=1 to parent.levels
                if lvl == sublvl
                    list.set(sublvl-1, format("active", list.get(sublvl)))
                else
                    list.set(sublvl-1, format("inactive", list.get(sublvl)))
            fields.put(key + lvl.toString(), list.joinBy(separator))
            destroy list

    /** Adds a level-dependant real-based field. */
    function setField(string key, RealLevelClosure rlc, string separator)
        setLvlFields(key, rlc.toStringList(parent.levels), separator)
    
    /** Adds a level-dependant int-based field. */ 
    function setField(string key, IntLevelClosure ilc, string separator)
        setLvlFields(key, ilc.toStringList(parent.levels), separator)
    
    /** Adds a level-dependant string-based field. */ 
    function setField(string key, StringLevelClosure slc, string separator)
        setLvlFields(key, slc.toStringList(parent.levels), separator)

    /* Preprocessing and processing */
            
    function processTemplate(int lvl) returns string
        string suffix = ""
        string processed = template

        fields.put("level", lvl.toString())
        fields.put("levels", parent.levels.toString())

        if lvl > 0
            suffix = lvl.toString()

        for field in template.getAllTemplateFields()
            var fieldVal = fields.get(field + suffix)
            if fieldVal == ""
                fieldVal = fields.get(field)
            processed = processed.r(field, fieldVal)

        return processed

    /** Returns the basic tooltip for a particular level. */
    function getTooltip(int lvl) returns string
        return processTemplate(lvl).process()
    
    /** Returns the basic tooltip. */
    function getTooltip() returns string
        return getTooltip(0)

    /** Sets the priority of this fragment, fragments with a lower priority are displayed first. */
    function setPriority(int priority)
        this.priority = priority

    function getPriority() returns int
        return this.priority

    construct(Tooltip parent)
        this.parent = parent

public function TooltipFragment.setHotkey(string value)
    this.setField("hotkey", value)

public function TooltipFragment.setHotkey(Hotkey hotkey)
    this.setField("hotkey", hotkey.getChar())

public function TooltipFragment.setAction(string value)
    this.setField("action", value)

public function TooltipFragment.setLevel(string value)
    this.setField("level", value)

public function TooltipFragment.setLevel(int value)
    this.setField("level", value.toString())

public function TooltipFragment.setName(string value)
    this.setField("name", value)

public function TooltipFragment.setValue(string value)
    this.setField("value", value)

public function TooltipFragment.set(string name, string value)
    this.setField("name", name)
    this.setField("value", value)

@Test function test()
    let tip = new Tooltip("Upgrade to", "This building", Hotkey.Q, 10)
    //tip.addFragment()..set("Something", "5")
    print("|n|n")
    tip.addFragment()
        ..setField("name", "HAXX")
        ..setField("value", (int lvl) -> lvl * 0.3, "/")
        ..setTemplate("{name} level is {level}/{levels} {value}")
    for i=1 to 10
        print(tip.getExtendedTip(i))